/*!
 * Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

import { getLogger } from "../logger/logger"

/**
 * A polling event. This is generated by a 'ListResources' call and is used to determine if a PollListener
 * should be removed from the event pool, firing callbacks.
 */
 export interface PollEvent<Model = any> {
    id: number | string
    model: Model
    retryAfter?: number
}

/**
 * A listener for resource updates. 
 */
export interface PollListener<Model = any> {
    id: number | string
    update(model: Model): void
    isPending(model: Model): boolean
}

interface PoolData<Model> { 
    model?: Model
    listener: PollListener<Model>
    collisions: number
    retryAfter: number 
}

interface PollManagerSettings {
    baseTime: number
    jitter: number 
    logging: boolean
}

export type PollManagerOptions = Partial<PollManagerSettings> & { name?: string }

const DEFAULT_SETTINGS: PollManagerSettings= {
    baseTime: 5000,
    jitter: 0.1,
    logging: false,
}

/**
 * Generic polling class. Allows for batch polling operations and asynchonrous updating resource models.
 */
export class PollManager<Model = any> {
    private listenerPool: Map<string, PoolData<Model>> = new Map()
    private pollTimer: NodeJS.Timeout | undefined
    protected timerEnd: number = Number.MAX_VALUE
    protected name: string
    protected settings: PollManagerSettings

    public constructor(
        // Unused args: maxPage and nextToken
        protected readonly listPollEvents: (maxPage?: number, nextToken?: string) => Promise<PollEvent<Model>[]>,
        options: PollManagerOptions = {}
    ) {
        this.name = options.name ?? '_' + Math.random().toString(36).substr(2, 12)
        this.settings = { ...DEFAULT_SETTINGS, ...options }
    }

    // Exponential backoff will only occur if the event's 'retryAfter' time occured before the current time
    private exponentialBackoff(collisions: number): number {
        const jitterOffset = (1 + this.settings.jitter * (Math.random() - 0.5))
        const backoff = (1 + Math.pow(2, Math.max(0, collisions)) * 0.5)
        return this.settings.baseTime * jitterOffset * backoff
    }

    protected logMessage(message: string): void {
        if (this.settings.logging) {
            getLogger().debug(`poll manager (${this.name}): ${message}`)
        }
    }

    // Updates collisions and returns the polling delta
    protected updateCollisions(): number {
        let pollDelta = Number.MAX_VALUE
        this.listenerPool.forEach(element => {
            if (element.retryAfter < Date.now()) {
                element.retryAfter = Date.now() + this.exponentialBackoff(++element.collisions)
            } else {
                element.retryAfter = Math.max(
                    element.retryAfter,
                    Date.now() + this.exponentialBackoff(element.collisions - 1)
                )
            }
            pollDelta = Math.min(pollDelta, element.retryAfter - Date.now())
        })
        return pollDelta
    }

    protected setTimer(delta: number) {
        if (this.pollTimer !== undefined) {
            clearTimeout(this.pollTimer)
        }
        this.pollTimer = setTimeout(() => this.updatePollEventPool(), delta)
        this.timerEnd = Date.now() + delta
    }

    public addPollListener(listener: PollListener<Model>, model?: Model): void {
        this.listenerPool.set(listener.id.toString(), {
            model: model,
            listener: listener,
            collisions: 0,
            retryAfter: Date.now() + this.settings.baseTime,
        })

        if (this.listenerPool.size === 1) {
            // start polling
            this.setTimer(this.settings.baseTime)
            this.logMessage('started')
        } else {
            // reset the timer
            this.setTimer(this.updateCollisions())
        }
    }

    public removePollListener(listener: PollListener<Model>): void {
        this.listenerPool.delete(listener.id.toString())

        if (this.listenerPool.size === 0 && this.pollTimer !== undefined) {
            clearTimeout(this.pollTimer)
        }
    }

    protected async updatePollEventPool(): Promise<void> {
        this.logMessage(`refresh ${new Date(Date.now()).toISOString()}`)
        const newPollEvents = await this.listPollEvents()
        newPollEvents.forEach(event => {
            const listener = this.listenerPool.get(event.id.toString())?.listener
             if (listener !== undefined && !listener.isPending(event.model)) {
                if (listener.update !== undefined) {
                    this.logMessage(`updated ${event.id}`)
                    listener.update(event.model)
                }
                this.removePollListener(listener)
            }
        })

        if (this.listenerPool.size !== 0) {
            // recalculate new time from group of events
            this.setTimer(this.updateCollisions())
        } else {
            this.logMessage('stopped')
        }
    }
}
